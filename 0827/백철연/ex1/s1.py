#13 정점의 개수 (간선 개수는 정점개수 -1, 그러니까 12)
#1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
#루트가 항상 1번이라고 짐작하지말자.. 문제마다 루트를 다르게 해야 할 수 있음
#1-2 1-3 ............    앞이 부모 뒤가 자식 노드
#부모: P 자식: C 정점수: V 간선수: V-1

# left = list(range(13))
# right = list(range(13))
# print(left)
# left[P] = C #부모를 인덱스로 자식번호 저장 / 먼저들어오면 왼쪽자식, 나중에 들어오면 오른쪽 자식
# if left[P] == 0:
#     left[P] = C
# else:
#     right[P] = C

#----------------------------------------------------------------------------------


# 13
# 1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
# 6
# 1 2 1 3 2 4 3 5 3 6
# 부모와 자식의 순서가 다르게 나올 수 도 있다?

def pre_order(n):
    if n:          # 유효한 정점이면
        print(n)
        pre_order(left[n])            # n의 왼쪽자식으로 이동
        pre_order(right[n])

V = int(input())
edge = list(map(int, input().split()))
E = V - 1 # V개의 정점이 있는 트리의 간선 수
left = [0]*(V+1) # 부모를 인덱스로 자식번호 저장
right = [0]*(V+1)
for i in range(E):
    p, c = edge[i*2], edge[i*2+1]
    if left[p] == 0: # p의 왼쪽자식이 없으면
        left[p] = c
    else:            # 왼쪽자식이 있으면 오른쪽자식으로 저장
        right[p] = c

pre_order(1)