# 동적 프로그래밍

> 함께 학습하고 고민하고 설명하며 작은 부분 하나라도 '내 것'으로 만들어보세요. 😁



## 2번

![image-20210925231741745](6_동적 프로그래밍.assets/image-20210925231741745.png)

![image-20210925232248396](6_동적 프로그래밍.assets/image-20210925232248396.png)

##### 풀이 bottom-up방식

``` python
#데이터 : n

#결과값 : f(n)
def fib(n):
    if n == 0 or n == 1:
        return n
    A = 0
    B = 1
    for _ in range(2, n+1):
        temp = A + B
        A = B
        B = temp
    return B

# 시간 복잡도 : O(n)
# 공간 복잡도 : O(1)
```

실제로 실행 시키면 memorization과 bottom-up 둘다 O(n)을 가지므로 기존 피보나치 O(2^n)보다 빨라진다.

