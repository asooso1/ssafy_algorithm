# 재귀


## 2번 - Merge Sort Time Complexity Proof

- Merge Sort가 진행되는 과정을 직접 그려보고 각 단계에서 어떤 일이 일어나는지 생각해보세요.
- 기초 수식에서 학습한 재귀식으로 표현하면 어떻게 되는지 같이 생각해보세요.

![재귀_2](5_재귀.assets/재귀_2.PNG)

```python
def merge_sort(arr):
    if len(arr) < 2:
        return arr
    
    middle = len(arr) // 2
    front_arr = merge_sort(arr[:middle])
    back_arr = merge_sort(arr[middle:])
    
    merged_arr = []
    low, high = 0
    while low < len(front_arr) and high < len(high_arr):
        if front_arr[low] < back_arr[high]:
            merged_arr.append(front_arr[low])
            low += 1
        else:
            merged_arr.append(front_arr[high])
            high += 1
    merged_arr += front_arr[low:]
    merged_arr += back_arr[high:]
    return merged_arr
```



```python
8 -> 4 -> 2 -> 1 식으로 반복의 수는 절반으로 줄어들 기 때문에 O(logN) 시간이 필요하다.
각 케이스에서 병합할 때 모든 값들을 비교해야 하므로 O(N) 시간이 소모됩니다. 
따라서 총 시간 복잡도는 O(NlogN) 입니다.
위의 merge_sort 방식은 두 개의 배열을 병합할 때 병합 결과를 담아 놓을 배열이 추가로 필요합니다. 
메모리 상으로 효율적이지 못한 구조인 것 같습니다.
다른 정렬 알고리즘과 달리 인접한 값들 간에 상호 자리 교대(swap)이 일어나지 않습니다.
```



```python
#메모리 사용량 개선 코드
def merge_sort(arr):
    def sort(low, high):
        if high - low < 2:
            return
        mid = (low + high) // 2
        sort(low, mid)
        sort(mid, high)
        merge(low, mid, high)

    def merge(low, mid, high):
        temp = []
        l, h = low, mid

        while l < mid and h < high:
            if arr[l] < arr[h]:
                temp.append(arr[l])
                l += 1
            else:
                temp.append(arr[h])
                h += 1

        while l < mid:
            temp.append(arr[l])
            l += 1
        while h < high:
            temp.append(arr[h])
            h += 1

        for i in range(low, high):
            arr[i] = temp[i - low]

    return sort(0, len(arr))
```



```python
블로그에서 참조를 했는데, 병합 결과를 담을 새로운 배열을 매번 생성해서 리턴하지 않고, 인덱스 접근을 이용해 입력 배열을 계속해서 업데이트하면 메모리 사용량을 대폭 줄일 수 있는 코드라고 설명되어있습니다.
```



## 4번 

![image-20210925231537705](5_재귀.assets/image-20210925231537705.png)

```c
Stupid(A[0..n-1])
{
    if n=2 and A[0]>A[1]
        then swap A[0] and A[1]
    else
        m=ceiling(2n/3)
        Stupid(A[0..m-1])
        Stupid(A[n-m..n-1])
        Stupid(A[0..m-1])
}
```

```python
Merge sort는 리스트를 두 개로 분할하는 과정을 재귀적으로 수행한 후, 다시 올라오며 각각을 정렬하며 합쳐지는 과정을 수행한다.

Swap의 경우 각 분할된 부분에서 (n *2)번의 Swap이 수행되므로 비교 횟수는 O(nlogn) 이 된다.
```

