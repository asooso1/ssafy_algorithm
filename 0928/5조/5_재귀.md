# 재귀

> 함께 학습하고 고민하고 설명하며 작은 부분 하나라도 '내 것'으로 만들어보세요. 😁




## 2번 - Merge Sort Time Complexity Proof

- Merge Sort가 진행되는 과정을 직접 그려보고 각 단계에서 어떤 일이 일어나는지 생각해보세요.
- 기초 수식에서 학습한 재귀식으로 표현하면 어떻게 되는지 같이 생각해보세요.

![재귀_2](5_재귀.assets/재귀_2.PNG)

```python
def MergeSort(A, start, end)
{
    if end > start:
    	middle = [(start + end)/2]
    	MergeSort(A, start, middle)
    	MergeSort(A, middle+1, end)
    	Merge(A, start, middle, end)
    else:
    	return
}
```

시간 복잡도

T(N) 

T(N/2)은 재귀에 의한 것, N은 merge의 개수

= 2*T(N/2) + N 

= 4*T(N/4) + 2N

...

= 2^k*T(N/2^k) + kN

(k = lgN이므로)

~ NlgN 





## 4번 

![image-20210925231537705](5_재귀.assets/image-20210925231537705.png)

2개의 원소를 쌍으로 가지고 있는 최소 집합에서 일어나는 swap 횟수 N/2,

그리고 최소 집합 2개가 merge된 집합에서 일어나는 swap 횟수 N/4,

이런 식으로 계속 모여 

N/2 + N/4 + ... + N/N = N개의 swap이 최대로 일어난다.






## 참고자료

http://www.bowdoin.edu/~ltoma/teaching/cs231/fall16/Lectures/02-recurrences/recurrences.pdf

https://www.cs.princeton.edu/courses/archive/spr07/cos226/lectures/04MergeQuick.pdf

